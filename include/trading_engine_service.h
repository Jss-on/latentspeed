/**
 * @file trading_engine_service.h
 * @brief Simplified trading engine service for Python integration
 * @author jessiondiwangan@gmail.com
 * @date 2025
 * 
 * SIMPLIFIED VERSION - This header defines only essential functionality:
 * - ZeroMQ-based order communication
 * - Order validation and acceptance
 * - Integration with Python strategies
 */

#pragma once

#include <string>
#include <memory>
#include <thread>
#include <atomic>
#include <functional>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <optional>
#include <variant>
#include <cstdint>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>

// Convenient logging macros with automatic function name and location
#define LOG_TRACE(...) SPDLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...) SPDLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...) SPDLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...) SPDLOG_WARN(__VA_ARGS__)
#define LOG_ERROR(...) SPDLOG_ERROR(__VA_ARGS__)
#define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)

// ZeroMQ
#include <zmq.hpp>

// JSON processing
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>

/**
 * @namespace latentspeed
 * @brief Main namespace for Latentspeed trading infrastructure
 */
namespace latentspeed {

/**
 * @struct ExecutionOrder
 * @brief Complete order specification for the trading engine
 * 
 * This is the main order structure that gets sent to the trading engine.
 * It contains all necessary information to execute any supported trading operation.
 */
struct ExecutionOrder {
    int version = 1;                 ///< Protocol version for compatibility
    std::string cl_id;               ///< Client order ID (unique); idempotency key
    std::string action;              ///< Order action: "place", "cancel", "replace"
    std::string venue_type;          ///< Venue category: "cex", "dex", "chain"
    std::string venue;               ///< Specific venue: "bybit", "binance", "uniswap_v3", etc.
    std::string product_type;        ///< Product type: "spot", "perpetual", "amm_swap", "clmm_swap", "transfer"
    std::map<std::string, std::string> details;            ///< Order-specific parameters
    uint64_t ts_ns;                  ///< Order timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Free-form metadata and routing tags
};

/**
 * @struct ExecutionReport
 * @brief Order execution status report
 * 
 * Generated by the trading engine to report the status of order processing.
 * Sent back to the strategy/client that submitted the original order.
 */
struct ExecutionReport {
    int version = 1;                 ///< Protocol version
    std::string cl_id;               ///< Client order ID from original order
    std::string status;              ///< Execution status: "accepted", "rejected", "canceled", "replaced"
    std::optional<std::string> exchange_order_id; ///< Exchange-assigned order ID
    std::string reason_code;         ///< Status code: "ok", "invalid_params", "risk_blocked", etc.
    std::string reason_text;         ///< Human-readable status description
    uint64_t ts_ns;                  ///< Report timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Metadata and routing information
};

/**
 * @struct Fill
 * @brief Trade execution fill report
 * 
 * Generated when an order gets filled (partially or completely).
 * Contains detailed execution information including price, size, and fees.
 */
struct Fill {
    int version = 1;                 ///< Protocol version
    std::string cl_id;               ///< Client order ID from original order
    std::optional<std::string> exchange_order_id; ///< Exchange-assigned order ID
    std::string exec_id;             ///< Unique execution ID for this fill
    std::string symbol_or_pair;      ///< Trading pair: "ETH/USDT" or "ETH->USDC"
    double price;                    ///< Execution price
    double size;                     ///< Filled quantity
    std::string fee_currency;        ///< Currency in which fees are charged
    double fee_amount;               ///< Fee amount paid
    std::optional<std::string> liquidity; ///< Liquidity type: "maker", "taker", or null
    uint64_t ts_ns;                  ///< Fill timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Metadata and routing information
};

/**
 * @class TradingEngineService
 * @brief Simplified trading engine for Python integration
 * 
 * Essential functionality only:
 * - ZeroMQ order communication 
 * - Order validation and acceptance
 * - ExecutionReport and Fill generation
 */
class TradingEngineService {
public:
    /**
     * @brief Simplified constructor
     * Sets up ZeroMQ endpoints and backtest parameters.
     */
    TradingEngineService();
    
    /**
     * @brief Destructor
     */
    ~TradingEngineService();
    
    /**
     * @brief Initialize the trading engine
     * @return true if initialization successful, false otherwise
     * 
     * Sets up ZeroMQ sockets and prepares all components
     * for operation. Must be called before start().
     */
    bool initialize();
    
    /**
     * @brief Start the trading engine service
     * 
     * Launches all worker threads for order processing and message publishing.
     * Non-blocking call.
     */
    void start();
    
    /**
     * @brief Stop the trading engine service
     * 
     * Gracefully shuts down all worker threads and cleans up resources.
     * Blocking call that waits for all threads to complete.
     */
    void stop();
    
    /**
     * @brief Check if the service is running
     * @return true if service is running, false otherwise
     */
    bool is_running() const { return running_; }

private:
    /// @name ZeroMQ Communication Threads
    /// @{
    /**
     * @brief Order receiver thread
     * 
     * Listens for ExecutionOrder messages on PULL socket and processes them.
     * Runs on tcp://127.0.0.1:5601 as specified in the message contract.
     */
    void zmq_order_receiver_thread();
    
    /**
     * @brief Publisher thread
     * 
     * Publishes ExecutionReport and Fill messages on PUB socket.
     * Runs on tcp://127.0.0.1:5602 as specified in the message contract.
     */
    void zmq_publisher_thread();
    /// @}
    
    /// @name Order Processing Methods
    /// @{
    /**
     * @brief Process an incoming execution order
     * @param order The ExecutionOrder to process
     * 
     * Main order processing entry point. Routes orders based on venue_type.
     */
    void process_execution_order(const ExecutionOrder& order);
    
    /**
     * @brief Calculate realistic fill price for order execution
     * @param order The order being filled
     * @return Calculated execution price including slippage
     */
    double calculate_fill_price(const ExecutionOrder& order);
    
    /**
     * @brief Generate fill report from market data
     * @param order The original ExecutionOrder
     * @param fill_price Calculated fill price
     * @param fill_size Calculated fill size
     */
    void generate_fill_from_market_data(const ExecutionOrder& order, double fill_price, double fill_size);
    /// @}
    
    /// @name Message Publishing
    /// @{
    /**
     * @brief Publish ExecutionReport message
     * @param report ExecutionReport to publish
     */
    void publish_execution_report(const ExecutionReport& report);
    
    /**
     * @brief Publish Fill message
     * @param fill Fill to publish
     */
    void publish_fill(const Fill& fill);
    /// @}
    
    /// @name Configuration Helpers (No-op in simplified version)
    /// @{
    std::vector<std::string> getExchangesFromConfig() const;
    std::vector<std::string> getSymbolsFromConfig() const;
    std::vector<std::string> getDynamicSymbolsFromExchange(
        const std::string& exchange_name,
        int top_n = 500,
        const std::string& quote_currency = "USDT") const;
    std::vector<std::string> parseCommaSeparated(const std::string& input) const;
    /// @}
    
    /// @name Message Parsing and Serialization
    /// @{
    /**
     * @brief Parse JSON message to ExecutionOrder
     * @param json_message JSON string to parse
     * @return Parsed ExecutionOrder object
     */
    ExecutionOrder parse_execution_order(const std::string& json_message);
    
    /**
     * @brief Serialize ExecutionReport to JSON
     * @param report ExecutionReport to serialize
     * @return JSON string representation
     */
    std::string serialize_execution_report(const ExecutionReport& report);
    
    /**
     * @brief Serialize Fill to JSON
     * @param fill Fill to serialize
     * @return JSON string representation
     */
    std::string serialize_fill(const Fill& fill);
    /// @}
    
    /// @name Utility Functions
    /// @{
    /**
     * @brief Get current time in nanoseconds
     * @return Current timestamp as nanoseconds since epoch
     */
    uint64_t get_current_time_ns();
    
    /**
     * @brief Generate unique execution ID
     * @return Unique execution identifier string
     */
    std::string generate_exec_id();
    
    /**
     * @brief Check if order has already been processed (idempotency)
     * @param cl_id Client order ID to check
     * @return true if already processed, false otherwise
     */
    bool is_duplicate_order(const std::string& cl_id);
    
    /**
     * @brief Mark order as processed for idempotency tracking
     * @param cl_id Client order ID to mark as processed
     */
    void mark_order_processed(const std::string& cl_id);
    /// @}
    
    /// @name ZeroMQ Components
    /// @{
    std::unique_ptr<zmq::context_t> zmq_context_;               ///< ZeroMQ context for socket management
    std::unique_ptr<zmq::socket_t> order_receiver_socket_;      ///< PULL socket for receiving orders
    std::unique_ptr<zmq::socket_t> report_publisher_socket_;    ///< PUB socket for publishing reports/fills
    /// @}
    
    /// @name Threading Components
    /// @{
    std::unique_ptr<std::thread> order_receiver_thread_;        ///< Thread for order reception
    std::unique_ptr<std::thread> publisher_thread_;             ///< Thread for message publishing
    std::atomic<bool> running_;                                 ///< Atomic flag for service state
    /// @}
    
    /// @name Service Configuration
    /// @{
    std::string order_endpoint_;                                ///< Order receiver endpoint (tcp://127.0.0.1:5601)
    std::string report_endpoint_;                               ///< Report publisher endpoint (tcp://127.0.0.1:5602)
    /// @}
    
    /// @name Order Tracking and State Management
    /// @{
    std::unordered_map<std::string, ExecutionOrder> pending_orders_;            ///< Pending orders (cl_id -> order)
    std::unordered_set<std::string> processed_orders_;                          ///< Processed orders set (idempotency tracking)
    /// @}
    
    /// @name Message Publishing Queue
    /// @{
    std::queue<std::string> publish_queue_;                     ///< Queue of messages to publish
    std::mutex publish_mutex_;                                  ///< Mutex protecting publish queue
    std::condition_variable publish_cv_;                        ///< Condition variable for publisher thread
    /// @}
    
    /// @name Backtest Parameters
    /// @{
    bool backtest_mode_;                                        ///< Always true in simplified version
    double fill_probability_;                                   ///< Order fill probability (0.0-1.0)
    double slippage_bps_;                                       ///< Additional execution slippage (basis points)
    /// @}
};

} // namespace latentspeed
