/**
 * @file trading_engine_service.h
 * @brief Simplified trading engine service for Python integration
 * @author jessiondiwangan@gmail.com
 * @date 2025
 * 
 * SIMPLIFIED VERSION - This header defines only essential functionality:
 * - ZeroMQ-based order communication
 * - Basic backtest simulation
 * - Integration with Python strategies
 * - Real-time market data publishing on port 5557
 */

#pragma once

#include <string>
#include <memory>
#include <thread>
#include <atomic>
#include <functional>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <optional>
#include <variant>
#include <cstdint>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <deque>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>

// Convenient logging macros with automatic function name and location
#define LOG_TRACE(...) SPDLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...) SPDLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...) SPDLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...) SPDLOG_WARN(__VA_ARGS__)
#define LOG_ERROR(...) SPDLOG_ERROR(__VA_ARGS__)
#define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)
#include <array>

// ZeroMQ
#include <zmq.hpp>

// JSON processing
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>

// CCAPI includes
#include "ccapi_cpp/ccapi_session.h"

/**
 * @namespace latentspeed
 * @brief Main namespace for Latentspeed trading infrastructure
 */
namespace latentspeed {

/**
 * @struct ExecutionOrder
 * @brief Complete order specification for the trading engine
 * 
 * This is the main order structure that gets sent to the trading engine.
 * It contains all necessary information to execute any supported trading operation.
 */
struct ExecutionOrder {
    int version = 1;                 ///< Protocol version for compatibility
    std::string cl_id;               ///< Client order ID (unique); idempotency key
    std::string action;              ///< Order action: "place", "cancel", "replace"
    std::string venue_type;          ///< Venue category: "cex", "dex", "chain"
    std::string venue;               ///< Specific venue: "bybit", "binance", "uniswap_v3", etc.
    std::string product_type;        ///< Product type: "spot", "perpetual", "amm_swap", "clmm_swap", "transfer"
    std::map<std::string, std::string> details;            ///< Order-specific parameters
    uint64_t ts_ns;                  ///< Order timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Free-form metadata and routing tags
};

/**
 * @struct ExecutionReport
 * @brief Order execution status report
 * 
 * Generated by the trading engine to report the status of order processing.
 * Sent back to the strategy/client that submitted the original order.
 */
struct ExecutionReport {
    int version = 1;                 ///< Protocol version
    std::string cl_id;               ///< Client order ID from original order
    std::string status;              ///< Execution status: "accepted", "rejected", "canceled", "replaced"
    std::optional<std::string> exchange_order_id; ///< Exchange-assigned order ID
    std::string reason_code;         ///< Status code: "ok", "invalid_params", "risk_blocked", etc.
    std::string reason_text;         ///< Human-readable status description
    uint64_t ts_ns;                  ///< Report timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Metadata and routing information
};

/**
 * @struct Fill
 * @brief Trade execution fill report
 * 
 * Generated when an order gets filled (partially or completely).
 * Contains detailed execution information including price, size, and fees.
 */
struct Fill {
    int version = 1;                 ///< Protocol version
    std::string cl_id;               ///< Client order ID from original order
    std::optional<std::string> exchange_order_id; ///< Exchange-assigned order ID
    std::string exec_id;             ///< Unique execution ID for this fill
    std::string symbol_or_pair;      ///< Trading pair: "ETH/USDT" or "ETH->USDC"
    double price;                    ///< Execution price
    double size;                     ///< Filled quantity
    std::string fee_currency;        ///< Currency in which fees are charged
    double fee_amount;               ///< Fee amount paid
    std::optional<std::string> liquidity; ///< Liquidity type: "maker", "taker", or null
    uint64_t ts_ns;                  ///< Fill timestamp in nanoseconds
    std::map<std::string, std::string> tags;  ///< Metadata and routing information
};

/**
 * @struct TradeData
 * @brief Trade execution data structure
 */
struct TradeData {
    std::string exchange;
    std::string symbol;
    std::string side;           // "buy" or "sell"
    double price;
    double amount;
    uint64_t timestamp_ns;
    std::string trade_id;
    
    // Derived features
    double transaction_price;
    double trading_volume;
    double volatility_transaction_price;
    int window_size;
    int transaction_price_window_size;  // Add missing field
    
    // Metadata
    int seq = 0;
    int sequence_number = 0;  // Add missing field
    int schema_version = 1;
    std::string preprocessing_timestamp;
    uint64_t receipt_timestamp_ns;
};

/**
 * @struct OrderBookData
 * @brief Order book snapshot data structure
 */
struct OrderBookData {
    std::string exchange;
    std::string symbol;
    uint64_t timestamp_ns;
    
    // Best bid/ask
    double best_bid_price;
    double best_bid_size;
    double best_ask_price;
    double best_ask_size;
    
    // Derived features
    double midpoint;
    double relative_spread;
    double breadth;
    double imbalance_lvl1;
    double bid_depth_n;
    double ask_depth_n;
    double depth_n;
    double volatility_mid;
    double ofi_rolling;
    
    // Full book data (optional)
    std::map<double, double> bids;  // price -> size
    std::map<double, double> asks;  // price -> size
    
    // Metadata
    int seq = 0;
    int sequence_number = 0;  // Add missing field
    int schema_version = 1;
    std::string preprocessing_timestamp;
    uint64_t receipt_timestamp_ns;
    int window_size;
    int midpoint_window_size;  // Add missing field
};

/**
 * @class FastRollingStats
 * @brief Fast rolling statistics calculation with circular buffer
 */
class FastRollingStats {
public:
    explicit FastRollingStats(size_t window_size = 20);
    
    struct TradeRollResult {
        double volatility_transaction_price;
        int transaction_price_window_size;
    };
    
    struct BookRollResult {
        double volatility_mid;
        double ofi_rolling;
        int midpoint_window_size;
    };
    
    TradeRollResult update_trade(double transaction_price);
    BookRollResult update_book(double midpoint, double best_bid_price, double best_bid_size, 
                               double best_ask_price, double best_ask_size);

private:
    size_t window_size_;
    std::deque<double> transaction_prices_;
    std::deque<double> midpoints_;
    std::deque<double> ofi_values_;
    
    double calculate_volatility(const std::deque<double>& values);
    double calculate_ofi(double best_bid_price, double best_bid_size, 
                        double best_ask_price, double best_ask_size);
};

/**
 * @class TradingEngineService
 * @brief Simplified trading engine for Python integration
 * 
 * Essential functionality only:
 * - ZeroMQ order communication 
 * - Basic backtest simulation
 * - ExecutionReport and Fill generation
 * - Real-time market data publishing on port 5557
 */
class TradingEngineService : public ccapi::EventHandler {
public:
    /**
     * @brief Simplified constructor
     * Sets up ZeroMQ endpoints and backtest parameters.
     */
    TradingEngineService();
    
    /**
     * @brief Destructor
     */
    ~TradingEngineService();
    
    /**
     * @brief Initialize the trading engine
     * @return true if initialization successful, false otherwise
     * 
     * Sets up ZeroMQ sockets and prepares all components
     * for operation. Must be called before start().
     */
    bool initialize();
    
    /**
     * @brief Start the trading engine service
     * 
     * Launches all worker threads for order processing and message publishing.
     * Non-blocking call.
     */
    void start();
    
    /**
     * @brief Stop the trading engine service
     * 
     * Gracefully shuts down all worker threads and cleans up resources.
     * Blocking call that waits for all threads to complete.
     */
    void stop();
    
    /**
     * @brief Check if the service is running
     * @return true if service is running, false otherwise
     */
    bool is_running() const { return running_; }
    
    /**
     * @brief CCAPI event handler override
     * @param event CCAPI event containing market data
     * @param session CCAPI session pointer
     */
    void processEvent(const ccapi::Event& event, ccapi::Session* session) override;

private:
    /// @name ZeroMQ Communication Threads
    /// @{
    /**
     * @brief Order receiver thread
     * 
     * Listens for ExecutionOrder messages on PULL socket and processes them.
     * Runs on tcp://127.0.0.1:5601 as specified in the message contract.
     */
    void zmq_order_receiver_thread();
    
    /**
     * @brief Publisher thread
     * 
     * Publishes ExecutionReport and Fill messages on PUB socket.
     * Runs on tcp://127.0.0.1:5602 as specified in the message contract.
     */
    void zmq_publisher_thread();
    
    /**
     * @brief Trade data publisher thread
     * 
     * Publishes preprocessed trade data to subscribers on port 5556.
     */
    void trade_data_publisher_thread();
    
    /**
     * @brief Orderbook data publisher thread
     * 
     * Publishes preprocessed orderbook data to subscribers on port 5557.
     */
    void orderbook_data_publisher_thread();
    /// @}
    
    /// @name Order Processing Methods
    /// @{
    /**
     * @brief Process an incoming execution order
     * @param order The ExecutionOrder to process
     * 
     * Main order processing entry point. Routes orders based on venue_type.
     */
    void process_execution_order(const ExecutionOrder& order);
    
    /**
     * @brief Simulate order execution in backtest mode
     * @param order The order to simulate
     */
    void simulate_order_execution(const ExecutionOrder& order);
    
    /**
     * @brief Simplified simulation implementation
     * @param order The order to simulate
     */
    void simulate_order_execution_simplified(const ExecutionOrder& order);
    
    /**
     * @brief Calculate realistic fill price for order execution
     * @param order The order being filled
     * @return Calculated execution price including slippage
     */
    double calculate_fill_price(const ExecutionOrder& order);
    
    /**
     * @brief Generate fill report from market data
     * @param order The original ExecutionOrder
     * @param fill_price Calculated fill price
     * @param fill_size Calculated fill size
     */
    void generate_fill_from_market_data(const ExecutionOrder& order, double fill_price, double fill_size);
    /// @}
    
    /// @name Message Publishing
    /// @{
    /**
     * @brief Publish ExecutionReport message
     * @param report ExecutionReport to publish
     */
    void publish_execution_report(const ExecutionReport& report);
    
    /**
     * @brief Publish Fill message
     * @param fill Fill to publish
     */
    void publish_fill(const Fill& fill);
    
    /**
     * @brief Process and publish trade data
     * @param trade_data Raw trade data from CCAPI
     */
    void process_trade_data(const TradeData& trade_data);
    
    /**
     * @brief Process and publish orderbook data
     * @param book_data Raw orderbook data from CCAPI
     */
    void process_orderbook_data(const OrderBookData& book_data);
    
    /**
     * @brief Publish trade data to ZMQ
     * @param trade_data Trade data to publish
     */
    void publish_trade_data(const TradeData& trade_data);
    
    /**
     * @brief Publish preprocessed trade data to separate endpoint
     * @param trade_data Preprocessed trade data to publish
     */
    void publish_preprocessed_trade_data(const TradeData& trade_data);
    
    /**
     * @brief Publish preprocessed orderbook data to separate endpoint
     * @param book_data Preprocessed orderbook data to publish
     */
    void publish_preprocessed_orderbook_data(const OrderBookData& book_data);
    /// @}
    
    /// @name Configuration Helpers
    /// @{
    /**
     * @brief Get exchanges from environment variable or default
     * @return Vector of exchange names
     */
    std::vector<std::string> getExchangesFromConfig() const;
    
    /**
     * @brief Get symbols from environment variable or default
     * @return Vector of symbol names
     */
    std::vector<std::string> getSymbolsFromConfig() const;
    
    /**
     * @brief Parse comma-separated string into vector
     * @param input Comma-separated string
     * @return Vector of strings
     */
    std::vector<std::string> parseCommaSeparated(const std::string& input) const;
    
    /**
     * @brief Validate exchange connectivity before starting subscriptions
     * @param exchanges List of exchanges to validate
     * @param symbols List of symbols to validate
     * @return true if all exchanges are reachable, false otherwise
     */
    bool validateExchangeConnectivity(const std::vector<std::string>& exchanges, 
                                    const std::vector<std::string>& symbols);
    
    /**
     * @brief Test connection to a specific exchange
     * @param exchange Exchange name to test
     * @param symbol Symbol to test with
     * @return true if connection successful, false otherwise
     */
    bool testExchangeConnection(const std::string& exchange, const std::string& symbol);
    /// @}
    
    /// @name Message Parsing and Serialization
    /// @{
    /**
     * @brief Parse JSON message to ExecutionOrder
     * @param json_message JSON string to parse
     * @return Parsed ExecutionOrder object
     */
    ExecutionOrder parse_execution_order(const std::string& json_message);
    
    /**
     * @brief Serialize ExecutionReport to JSON
     * @param report ExecutionReport to serialize
     * @return JSON string representation
     */
    std::string serialize_execution_report(const ExecutionReport& report);
    
    /**
     * @brief Serialize Fill to JSON
     * @param fill Fill to serialize
     * @return JSON string representation
     */
    std::string serialize_fill(const Fill& fill);
    
    /**
     * @brief Serialize data to JSON or MessagePack
     * @param data Data object to serialize
     * @return Serialized bytes
     */
    template<typename T>
    std::vector<uint8_t> serialize_data(const T& data);
    /// @}
    
    /// @name Utility Functions
    /// @{
    /**
     * @brief Get current time in nanoseconds
     * @return Current timestamp as nanoseconds since epoch
     */
    uint64_t get_current_time_ns();
    
    /**
     * @brief Generate unique execution ID
     * @return Unique execution identifier string
     */
    std::string generate_exec_id();
    
    /**
     * @brief Check if order has already been processed (idempotency)
     * @param cl_id Client order ID to check
     * @return true if already processed, false otherwise
     */
    bool is_duplicate_order(const std::string& cl_id);
    
    /**
     * @brief Mark order as processed for idempotency tracking
     * @param cl_id Client order ID to mark as processed
     */
    void mark_order_processed(const std::string& cl_id);
    
    /**
     * @brief Normalize exchange name
     * @param exchange Raw exchange name
     * @return Normalized exchange name (uppercase)
     */
    std::string normalize_exchange(const std::string& exchange);
    
    /**
     * @brief Normalize symbol
     * @param symbol Raw symbol
     * @return Normalized symbol (consistent dash separator)
     */
    std::string normalize_symbol(const std::string& symbol);
    
    /**
     * @brief Get next sequence number for a stream
     * @param partition_id Stream partition identifier (exchange:symbol:type)
     * @return Next sequence number
     */
    int get_next_sequence(const std::string& partition_id);
    
    /**
     * @brief Start market data subscriptions via CCAPI
     */
    void start_market_data_subscriptions();
    
    /**
     * @brief Stop market data subscriptions
     */
    void stop_market_data_subscriptions();
    
    /**
     * @brief Publish orderbook data to ZMQ
     * @param book_data Orderbook data to publish
     */
    void publish_orderbook_data(const OrderBookData& book_data);
    
    /**
     * @brief Serialize orderbook data to JSON
     * @param book_data Orderbook data to serialize
     * @return JSON string representation
     */
    std::string serialize_orderbook_data(const OrderBookData& book_data);
    
    /**
     * @brief Serialize trade data to JSON
     * @param trade_data Trade data to serialize
     * @return JSON string representation
     */
    std::string serialize_trade_data(const TradeData& trade_data);
    /// @}
    
    /// @name ZeroMQ Components
    /// @{
    std::unique_ptr<zmq::context_t> zmq_context_;               ///< ZeroMQ context for socket management
    std::unique_ptr<zmq::socket_t> order_receiver_socket_;      ///< PULL socket for receiving orders
    std::unique_ptr<zmq::socket_t> report_publisher_socket_;    ///< PUB socket for publishing reports/fills
    std::unique_ptr<zmq::socket_t> trade_data_publisher_socket_; ///< PUB socket for publishing trade data on port 5556
    std::unique_ptr<zmq::socket_t> orderbook_data_publisher_socket_; ///< PUB socket for publishing orderbook data on port 5557
    /// @}
    
    /// @name CCAPI Components
    /// @{
    std::unique_ptr<ccapi::Session> ccapi_session_;             ///< CCAPI session for market data
    ccapi::SessionOptions ccapi_session_options_;              ///< CCAPI session options
    ccapi::SessionConfigs ccapi_session_configs_;              ///< CCAPI session configurations
    std::vector<ccapi::Subscription> ccapi_subscriptions_;     ///< Active CCAPI subscriptions
    /// @}
    
    /// @name Threading Components
    /// @{
    std::unique_ptr<std::thread> order_receiver_thread_;        ///< Thread for order reception
    std::unique_ptr<std::thread> publisher_thread_;             ///< Thread for message publishing
    std::unique_ptr<std::thread> trade_data_publisher_thread_;  ///< Thread for trade data publishing
    std::unique_ptr<std::thread> orderbook_data_publisher_thread_; ///< Thread for orderbook data publishing
    std::atomic<bool> running_;                                 ///< Atomic flag for service state
    /// @}
    
    /// @name Service Configuration
    /// @{
    std::string order_endpoint_;                                ///< Order receiver endpoint (tcp://127.0.0.1:5601)
    std::string report_endpoint_;                               ///< Report publisher endpoint (tcp://127.0.0.1:5602)
    std::string trade_data_endpoint_;                           ///< Trade data publisher endpoint (tcp://127.0.0.1:5556)
    std::string orderbook_data_endpoint_;                       ///< Orderbook data publisher endpoint (tcp://127.0.0.1:5557)
    /// @}
    
    /// @name Market Data Configuration
    /// @{
    std::string serializer_type_;                               ///< Serializer: "json" or "msgpack"
    int window_size_;                                           ///< Rolling statistics window size
    int depth_levels_;                                          ///< Orderbook depth levels to process
    bool snapshots_only_;                                       ///< Only process snapshots (not incremental updates)
    int snapshot_interval_;                                     ///< Snapshot throttling interval
    int sndhwm_;                                               ///< ZMQ send high water mark
    int linger_ms_;                                            ///< ZMQ linger time in milliseconds
    /// @}

    /// @name Market Data State Management
    /// @{
    std::queue<TradeData> trade_data_queue_;                    ///< Queue of trade data to publish
    std::queue<OrderBookData> book_data_queue_;                 ///< Queue of orderbook data to publish
    std::queue<std::string> trade_data_message_queue_;          ///< Trade data message queue for publishing
    std::queue<std::string> orderbook_data_message_queue_;      ///< Orderbook data message queue for publishing
    std::mutex trade_data_mutex_;                               ///< Mutex protecting trade data queue
    std::mutex orderbook_data_mutex_;                           ///< Mutex protecting orderbook data queue
    std::condition_variable trade_data_cv_;                     ///< Condition variable for trade data publisher thread
    std::condition_variable orderbook_data_cv_;                 ///< Condition variable for orderbook data publisher thread
    
    std::unordered_map<std::string, int> sequence_numbers_;     ///< Per-stream sequence numbers
    std::unordered_map<std::string, FastRollingStats> symbol_stats_; ///< Per-symbol rolling statistics
    std::unordered_map<std::string, int> snapshot_counts_;      ///< Per-symbol snapshot counts (for throttling)
    /// @}
    
    /// @name Order Tracking and State Management
    /// @{
    std::unordered_map<std::string, ExecutionOrder> pending_orders_;            ///< Pending orders (cl_id -> order)
    std::unordered_set<std::string> processed_orders_;                          ///< Processed orders set (idempotency tracking)
    /// @}
    
    /// @name Message Publishing Queue
    /// @{
    std::queue<std::string> publish_queue_;                     ///< Queue of messages to publish
    std::mutex publish_mutex_;                                  ///< Mutex protecting publish queue
    std::condition_variable publish_cv_;                        ///< Condition variable for publisher thread
    /// @}
    
    /// @name Backtest Parameters
    /// @{
    bool backtest_mode_;                                        ///< Always true in simplified version
    double fill_probability_;                                   ///< Order fill probability (0.0-1.0)
    double slippage_bps_;                                       ///< Additional execution slippage (basis points)
    /// @}
};

} // namespace latentspeed
